{
  "milestone": "3.2",
  "title": "Configure Network Kernel Modules",
  "description": "CIS Ubuntu Linux 24.04 LTS Benchmark - Section 3.2: Configure Network Kernel Modules",
  "version": "1.0.0",
  "controls": [
    {
      "id": "3.2.1",
      "title": "Ensure dccp kernel module is not available",
      "section": "3.2 Configure Network Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "dccp",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "3.2.1",
      "description": "NTP= • A space -separated list of NTP server host names or IP addresses. During runtime this list is combined with any per -interface NTP servers acquired from systemd -networkd.service(8). systemd -timesyncd will contact all configured system or per -interface server s in turn, until one responds. When the empty string is assigned, the list of NTP servers is reset, and all prior assignments will have no effect. This setting defaults to an empty list.\nFallbackNTP= • A space -separated list of NTP server host names or IP addresses to be used as the fallback NTP servers. Any per -interface NTP servers obtained from systemd - networkd.service(8) take precedence over this setting, as do any servers set via NTP= above. This se tting is hence only relevant if no other NTP server information is known. When the empty string is assigned, the list of NTP servers is reset, and all prior assignments will have no effect. If this option is not given, a compiled -in list of NTP servers is used.",
      "remediation": "Set NTP and/or FallbackNPT parameters to local site approved authoritative time server(s) in /etc/systemd/timesyncd.conf or a file in /etc/systemd/timesyncd.conf.d/ ending in .conf in the [Time] section:\nExample file:\n[Time] NTP=time.nist.gov # Uses the generic name for NIST's time servers FallbackNTP=time -a-g.nist.gov time -b-g.nist.gov time -c-g.nist.gov # Space separated list of NIST time servers Example script to create systemd drop -in configuration file:\n#!/usr/bin/env bash a_settings=(\"NTP=time.nist.gov\" \"FallbackNTP=time -a-g.nist.gov time -b- g.nist.gov time -c-g.nist.gov\") [ ! -d /etc/systemd/timesyncd.conf.d/ ] && mkdir /etc/systemd/timesyncd.conf.d/ if grep -Psq -- '^*\\[Time\\]' /etc/systemd /timesyncd.conf.d/60 - timesyncd.conf; then printf '%s ' \"\" \"$a_settings[@]\" >> /etc/systemd/timesyncd.conf.d/60 -timesyncd.conf else printf '%s ' \"\" \"[Time]\" \"$a_settings[@]\" >> /etc/systemd/timesyncd.conf.d/60 -timesyncd.conf fi Note: If this setting appears in a canonically later file, or later in the same file, the\nsetting will be overwritten\nRun to following command to update the parameters in the service:\n# systemctl reload -or-restart systemd -journald"
    },
    {
      "id": "3.2.2",
      "title": "Ensure tipc kernel module is not available",
      "section": "3.2 Configure Network Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "tipc",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "3.2.2",
      "description": "systemd -timesyncd is a daemon that has been added for synchronizing the system clock across the network",
      "remediation": "- IF - systemd-timesyncd is in use on the system, run the following commands:\nRun the following command to unmask systemd-timesyncd.service :\n# systemctl unmask systemd -timesyncd.service\nRun the following command to enable and start systemd-timesyncd.service :\n# systemctl --now enable systemd -timesyncd.service - OR - If another time synchronization service is in use on the system, run the following command to stop and mask systemd-timesyncd :\n# systemctl --now mask systemd -timesyncd.service"
    },
    {
      "id": "3.2.3",
      "title": "Ensure rds kernel module is not available",
      "section": "3.2 Configure Network Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "rds",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "3.2.3",
      "description": "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide low -latency, high -bandwidth communications between cluster nodes. It was developed by the Oracle Corporation.",
      "remediation": "Run the following script to unload and disable the rds module:\n- IF - the rds kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install rds /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist rds in the /etc/modprobe.d/ directory • Run modprobe -r rds 2>/dev/null; rmmod rds 2>/dev/null to remove rds from the kernel - IF - the rds kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"rds\" l_mod_type=\"net\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showc onfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kern el module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_directo ry in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_b ase_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "3.2.4",
      "title": "Ensure sctp kernel module is not available",
      "section": "3.2 Configure Network Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "sctp",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "3.2.4",
      "description": "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol used to support message oriented communication, with several streams of messages in one connection. It serves a similar function as TCP and UDP, incorporating features of both.\nIt is message -oriented like UDP, and ensures reliable in -sequence transport of messages with congestion control like TCP.",
      "remediation": "Run the following script to unload and disable the sctp module:\n- IF - the sctp kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install sctp /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist sctp in the /etc/modprobe.d/ directory • Run modprobe -r sctp 2>/dev/null; rmmod sctp 2>/dev/null to remove sctp from the kernel - IF - the sctp kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"sctp\" l_mod_type=\"net\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_show config; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading ker nel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_direct ory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_ base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    }
  ]
}