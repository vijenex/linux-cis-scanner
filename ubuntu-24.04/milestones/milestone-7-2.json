{
  "milestone": "7.2",
  "title": "Local User and Group Settings",
  "description": "CIS Ubuntu Linux 24.04 LTS Benchmark - Section 7.2: Local User and Group Settings",
  "version": "1.0.0",
  "controls": [
    {
      "id": "7.2.1",
      "title": "Ensure accounts in /etc/passwd use shadowed passwords",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "ShadowedPasswords",
      "passwd_file": "/etc/passwd",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.1",
      "description": "Local accounts can uses shadowed passwords. With shadowed passwords, The passwords are saved in shadow password file, /etc/shadow , encrypted by a salted one-way hash. Accounts with a shadowed password have an x in the second field in /etc/passwd .",
      "remediation": "Run the following command to set accounts to use shadowed passwords and migrate passwords in /etc/passwd to /etc/shadow :\n# pwconv Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off."
    },
    {
      "id": "7.2.2",
      "title": "Ensure /etc/shadow password fields are not empty",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "EmptyPasswords",
      "shadow_file": "/etc/shadow",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.2",
      "description": "An account with an empty password field means that anybody may log in as that user without providing a password.",
      "remediation": "If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:\n# passwd -l <username> Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off."
    },
    {
      "id": "7.2.3",
      "title": "Ensure all groups in /etc/passwd exist in /etc/group",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "GroupConsistency",
      "passwd_file": "/etc/passwd",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.3",
      "description": "Over time, system administration errors and changes can lead to groups being defined in /etc/passwd but not in /etc/group .",
      "remediation": "Analyze the output of the Audit step above and perform the appropriate action to correct any discrepancies found."
    },
    {
      "id": "7.2.4",
      "title": "Ensure shadow group is empty",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "EmptyGroup",
      "group_name": "shadow",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.4",
      "description": "The shadow group allows system programs which require access the ability to read the /etc/shadow file. No users should be assigned to the shadow group.",
      "remediation": "Run the following command to remove all users from the shadow group\n# sed -ri 's/(^shadow:[^:]*:[^:]*:)([^:]+$)/ \\1/' /etc/group Change the primary group of any users with shadow as their primary group.\n# usermod -g <primary group> <user>"
    },
    {
      "id": "7.2.5",
      "title": "Ensure no duplicate UIDs exist",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "DuplicateUIDs",
      "passwd_file": "/etc/passwd",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.5",
      "description": "Although the useradd program will not let you create a duplicate User ID (UID), it is possible for an administrator to manually edit the /etc/passwd file and change the UID field.",
      "remediation": "Based on the results of the audit script, establish unique UIDs and review all files owned by the shared UIDs to determine which UID they are supposed to belong to."
    },
    {
      "id": "7.2.6",
      "title": "Ensure no duplicate GIDs exist",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "DuplicateGIDs",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.6",
      "description": "Although the groupadd program will not let you create a duplicate Group ID (GID), it is possible for an administrator to manually edit the /etc/group file and change the GID field.",
      "remediation": "Based on the results of the audit script, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to."
    },
    {
      "id": "7.2.7",
      "title": "Ensure no duplicate user names exist",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "DuplicateUsernames",
      "passwd_file": "/etc/passwd",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.7",
      "description": "Although the useradd program will not let you create a duplicate user name, it is possible for an administrator to manually edit the /etc/passwd file and change the user name.",
      "remediation": "Based on the results of the audit script, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs."
    },
    {
      "id": "7.2.8",
      "title": "Ensure no duplicate group names exist",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "DuplicateGroupnames",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.8",
      "description": "Although the groupadd program will not let you create a duplicate group name, it is possible for an administrator to manually edit the /etc/group file and change the group name.",
      "remediation": "Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs."
    },
    {
      "id": "7.2.9",
      "title": "Ensure local interactive user home directories are configured",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "UserHomeDirs",
      "passwd_file": "/etc/passwd",
      "min_uid": 1000,
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.9",
      "description": "The user home directory is space defined for the particular user to set local environment variables and to store personal files. While the system administrator can establish secure permissions for users' home directories, the users can easily override thes e.\nUsers can be defined in /etc/passwd without a home directory or with a home directory that does not actually exist.",
      "remediation": "If a local interactive users' home directory is undefined and/or doesn't exist, follow local site policy and perform one of the following:\n• Lock the user account • Remove the user from the system • create a directory for the user. If undefined, edit /etc/passwd and add the absolute path to the directory to the last field of the user.\nRun the following script to:\n• Remove excessive permissions from local interactive users home directories • Update the home directory's owner\n#!/usr/bin/env bash l_output2=\"\" l_valid_shells=\"^($( awk -F\\/ '$NF != \"nologin\" print' /etc/shells | sed -rn '/^\\//s,/,\\\\\\\\/,g;p' | paste -s -d '|' - ))$\" unset a_uarr && a_uarr=() # Clear and initialize array while read -r l_epu l_eph; do # Populate array with users and user home location a_uarr+=(\"$l_epu $l_eph\") done <<< \"$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat print $1 \" \"\n$(NF-1) ' /etc/passwd)\" l_asize=\"$#a_uarr[@]\" # Here if we want to look at number of us ers before proceeding [ \"$l_asize \" -gt \"10000\" ] && echo -e \" ** INFO ** - \\\"$l_asize \\\" Local interactive users found on the system - This may be a long running process\" while read -r l_user l_home; do if [ -d \"$l_home\" ]; then l_mask='0027' l_max=\"$( printf '%o' $(( 0777 & ~$l_mask)) )\" while read -r l_own l_mode; do if [ \"$l_user\" != \"$l_own\" ]; then l_output2=\"$l_output2 - User: \\\"$l_user \\\" Home \\\"$l_home \\\" is owned by: \\\"$l_own\\\" - changing ownership to: \\\"$l_user \\\"\" chown \"$l_user\" \"$l_home\" fi if [ $(( $l_mode & $l_mask )) -gt 0 ]; then l_output2=\"$l_output2 - User: \\\"$l_user \\\" Home \\\"$l_home \\\" is mode: \\\"$l_mode\\\" should be mode: \\\"$l_max\\\" or more restrictive - removing excess permissions \" chmod g-w,o-rwx \"$l_home\" fi done <<< \"$(stat -Lc '%U %#a' \"$l_home\")\" else l_output2=\"$l_output2 - User: \\\"$l_user\\\" Home \\\"$l_home \\\" Doesn't exist - Please create a home in accordance with local site policy\" fi done <<< \"$(printf '%s ' \"$a_uarr[@]\")\" if [ -z \"$l_output2\" ]; then # If l_output2 is empty, we pass echo -e \" - No modification needed to local interactive users home directories\" else echo -e \"$l_output2\" fi"
    },
    {
      "id": "7.2.10",
      "title": "Ensure local interactive user dot files access is configured",
      "section": "7.2 Local User and Group Settings",
      "profile": "Level1",
      "automated": true,
      "type": "UserDotFiles",
      "passwd_file": "/etc/passwd",
      "min_uid": 1000,
      "max_permissions": "go-w",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.10",
      "description": "While the system administrator can establish secure permissions for users' \"dot\" files, the users can easily override these.\n• .forward file specifies an email address to forward the user's mail to.\n• .rhost file provides the \"remote authentication\" database for the rcp, rlogin, and rsh commands and the rcmd() function. These files bypass the standard password -based user authentication mechanism. They specify remote hosts and users that are considered trusted (i.e. are allowed to access the local system without supplying a password) • .netrc file contains data for logging into a remote host or passing authentication to an API.\n• .bash_history file keeps track of the user’s commands.",
      "remediation": "Making global modifications to users' files without alerting the user community can result in unexpected outages and unhappy users. Therefore, it is recommended that a monitoring policy be established to report user dot file permissions and determine the action to be taken in accordance with site policy.\nThe following script will:\n• remove excessive permissions on dot files within interactive users' home directories • change ownership of dot files within interactive users' home directories to the user • change group ownership of dot files within interactive users' home directories to the user's primary group • list .forward and .rhost files to be investigated and manually deleted\n#!/usr/bin/env bash a_output2=(); a_output3=() l_maxsize=\"1000\" # Maximum number of local interactive users before warning (Default 1,000) l_valid_shells=\"^($( awk -F\\/ '$NF != \"nologin\" print' /etc/shells | sed -rn '/^\\//s,/,\\\\\\\\/,g;p' | p aste -s -d '|' - ))$\" a_user_and_home=() # Create array with local users and their home directories while read -r l_local_user l_local_user_home; do # Populate array with users and user home location [[ -n \"$l_local_user\" && -n \"$l_local_user_h ome\" ]] && a_user_and_home+=(\"$l_local_user:$l_local_user_home\") done <<< \"$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat print $1 \" \"\n$(NF-1) ' /etc/passwd)\" l_asize=\"$#a_user_and_home[@]\" # Here if we want to look at number of users before pr oceeding [ \"$#a_user_and_home[@]\" -gt \"$l_maxsize\" ] && printf '%s ' \"\" \" ** INFO **\" \\ \" - \\\"$l_asize \\\" Local interactive users found on the system\" \\ \" - This may be a long running check\" \"\" file_access_fix() a_access_out=() l_max=\"$( printf '%o' $(( 0777 & ~$l_mask)) )\" if [ $(( $l_mode & $l_mask )) -gt 0 ]; then printf '%s ' \"\" \" - File: \\\"$l_hdfile \\\" is mode: \\\"$l_mode \\\" and should be mode: \\\"$l_max\\\" or more restrictive\" \\ \" Updating fil e: \\\"$l_hdfile \\\" to be mode: \\\"$l_max\\\" or more restrictive\" chmod \"$l_change\" \"$l_hdfile\" fi if [[ ! \"$l_owner\" =~ ($l_user) ]]; then printf '%s ' \"\" \" - File: \\\"$l_hdfile \\\" owned by: \\\"$l_owner \\\" and should be owned by \\\"$l_user//|/ or \\\"\" \\ \" Updating file: \\\"$l_hdfile \\\" to be owned by \\\"$l_user//|/ or \\\"\" chown \"$l_user\" \"$l_hdfile\" fi if [[ ! \"$l_gowner\" =~ ($l_group) ]]; then printf '%s ' \"\" \" - File: \\\"$l_hdfile \\\" group owned by:\n\\\"$l_gowner \\\" and should be group owned by \\\"$l_group//|/ or \\\"\" \\ \" Updating file: \\\"$l_hdfile \\\" to be group owned by \\\"$l_group//|/ or \\\"\" chgrp \"$l_group\" \"$l_hdfile\" fi while IFS=: read -r l_user l_home ; do a_dot_file=(); a_netrc=(); a_netrc_warn=(); a_bhout=(); a_hdirout=() if [ -d \"$l_home\" ]; then l_group=\"$(id -gn \"$l_user\" | xargs)\";l_group=\"$l_group// /|\" while IFS= read -r -d $'\\0' l_hdfile; do while rea d -r l_mode l_owner l_gowner; do case \"$(basename \"$l_hdfile\")\" in .forward | .rhost ) a_dot_file+=(\" - File: \\\"$l_hdfile \\\" exists\" \" Please review and manually delete this file\") ;;\n.netrc ) l_mask='0177'; l_change=\"u -x,go-rwx\"; file_access_fix a_netrc_warn+=(\" - File: \\\"$l_hdfile \\\" exists\") ;;\n.bash_history ) l_mask='0177'; l_change=\"u -x,go-rwx\"; file_access_fix ;;\n* ) l_mask='0133'; l_change=\"u -x,go-wx\"; file_access_fix ;;\nesac done < <(stat -Lc '%#a %U %G' \"$l_hdfile\") done < <(find \"$l_home\" -xdev -type f -name '.*' -print0) fi [ \"$#a_dot_file[@]\" -gt 0 ] && a_output2+=(\" - User: \\\"$l_user \\\" Home Directory: \\\"$l_home \\\"\" \"$a_dot_file[@]\") [ \"$#a_netrc_warn[@]\" -gt 0 ] && a_output3+=(\" - User: \\\"$l_user \\\" Home Directory: \\\"$l_home \\\"\" \"$a_netrc_warn[@]\") done <<< \"$(printf '%s ' \"$a_user_and_home[@]\")\" [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" ** WARNING **\" \"$a_output3[@]\" \"\" [ \"$#a_output2[@]\" -gt 0 ] && printf ' %s' \"\" \"$a_output2[@]\""
    }
  ]
}