{
  "milestone": "1.1",
  "title": "Filesystem Configuration",
  "description": "CIS Ubuntu Linux 24.04 LTS Benchmark - Section 1.1: Filesystem Configuration",
  "version": "1.0.0",
  "controls": [
    {
      "id": "1.1.1.1",
      "title": "Ensure cramfs kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "cramfs",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.1",
      "description": "The cramfs filesystem type is a compressed read -only Linux filesystem embedded in small footprint systems. A cramfs image can be used without having to first decompress the image.",
      "remediation": "Run the following script to unload and disable the cramfs module:\n- IF - the cramfs kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install cramfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist cramfs in the /etc/modprobe.d/ directory • Run modprobe -r cramfs 2>/dev/null; rmmod cramfs 2>/dev/null to\nremove cramfs from the kernel - IF - the cramfs kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"cramfs\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading ke rnel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_direc tory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.2",
      "title": "Ensure freevxfs kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "freevxfs",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.2",
      "description": "The freevxfs filesystem type is a free version of the Veritas type filesystem. This is the primary filesystem type for HP -UX operating systems.",
      "remediation": "Run the following script to unload and disable the freevxfs module:\n- IF - the freevxfs kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install freevxfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist freevxfs in the /etc/modprobe.d/ directory • Run modprobe -r freevxfs 2>/dev/null; rmmod freevxfs 2>/dev/null to remove freevxfs from the kernel - IF - the freevxfs kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"freevxfs\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kernel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_dir ectory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.3",
      "title": "Ensure hfs kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "hfs",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.3",
      "description": "The hfs filesystem type is a hierarchical filesystem that allows you to mount Mac OS filesystems.",
      "remediation": "Run the following script to unload and disable the hfs module:\n- IF - the hfs kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install hfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist hfs in the /etc/modprobe.d/ directory • Run modprobe -r hfs 2>/dev/null; rmmod hfs 2>/dev/null to remove hfs from the kernel - IF - the hfs kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"hfs\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showco nfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kerne l module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_director y in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_ba se_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.4",
      "title": "Ensure hfsplus kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "hfsplus",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.4",
      "description": "The hfsplus filesystem type is a hierarchical filesystem designed to replace hfs that allows you to mount Mac OS filesystems.",
      "remediation": "Run the following script to unload and disable the hfsplus module:\n- IF - the hfsplus kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install hfsplus /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist hfsplus in the /etc/modprobe.d/ directory • Run modprobe -r hfsplus 2>/dev/null; rmmod hfsplus 2>/dev/null to\nremove hfsplus from the kernel - IF - the hfsplus kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"hfsplus\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading k ernel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_dire ctory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.5",
      "title": "Ensure jffs2 kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "jffs2",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.5",
      "description": "The jffs2 (journaling flash filesystem 2) filesystem type is a log -structured filesystem used in flash memory devices.",
      "remediation": "Run the following script to unload and disable the jffs2 module:\n- IF - the jffs2 kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install jffs2 /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist jffs2 in the /etc/modprobe.d/ directory • Run modprobe -r jffs2 2>/dev/null; rmmod jffs2 2>/dev/null to\nremove jffs2 from the kernel - IF - the jffs2 kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"jffs2\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_show config; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading ker nel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_direct ory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_ base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.6",
      "title": "Ensure overlayfs kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "overlay",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.6",
      "description": "overlayfs is a Linux filesystem that layers multiple filesystems to create a single unified view which allows a user to \"merge\" several mount points into a unified filesystem.",
      "remediation": "Run the following script to unload and disable the overlayfs module:\n- IF - the overlayfs kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install overlayfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist overlayfs in the /etc/modprobe.d/ directory • Run modprobe -r overlayfs 2>/dev/null; rmmod overlayfs 2>/dev/null to remove overlayfs from the kernel - IF - the overlayfs kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"overlayfs\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kernel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_di rectory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.7",
      "title": "Ensure squashfs kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "squashfs",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.7",
      "description": "The squashfs filesystem type is a compressed read -only Linux filesystem embedded in small footprint systems. A squashfs image can be used without having to first decompress the image.",
      "remediation": "Run the following script to unload and disable the udf module:\n- IF - the squashfs kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install squashfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist squashfs in the /etc/modprobe.d/ directory • Run modprobe -r squashfs 2>/dev/null; rmmod squashfs 2>/dev/null to remove squashfs from the kernel - IF - the squashfs kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"squashfs\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kernel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_dir ectory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.8",
      "title": "Ensure udf kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "udf",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.8",
      "description": "The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA -167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats.",
      "remediation": "Run the following script to unload and disable the udf module:\n- IF - the udf kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install udf /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist udf in the /etc/modprobe.d/ directory • Run modprobe -r udf 2>/dev/null; rmmod udf 2>/dev/null to remove udf from the kernel - IF - the udf kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"udf\" l_mod_type=\"fs\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= read -r l_showco nfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kerne l module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_director y in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_ba se_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.9",
      "title": "Ensure usb-storage kernel module is not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": true,
      "type": "KernelModule",
      "module_name": "usb-storage",
      "expected_status": "not_available",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.9",
      "description": "USB storage provides a means to transfer and store files ensuring persistence and availability of the files independent of network connection status. Its popularity and utility has led to USB -based malware being a simple and common means for network infiltration and a first step to establishing a persistent threat within a networked environment.",
      "remediation": "Run the following script to unload and disable the usb-storage module:\n- IF - the usb-storage kernel module is available in ANY installed kernel:\n• Create a file ending in .conf with install usb -storage /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist usb -storage in the /etc/modprobe.d/ directory • Run modprobe -r usb-storage 2>/dev/null; rmmod usb -storage 2>/dev/null to remove usb-storage from the kernel - IF - the usb-storage kernel module is not available on the system, or pre -compiled into the kernel, no remediation is necessary\n#!/usr/bin/env bash a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"usb -storage\" l_mod_type=\"drivers\" l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" a_showconfig=() while IFS= rea d -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_chk_name// -/_\"'') if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then a_output2+=(\" - unloading kernel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_chk_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlink -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_chk_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_ base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") l_mod_chk_name=\"$l_mod_name\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else printf '%s ' \" - kernel module: \\\"$l_mod_name \\\" doesn't exist i n \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.1.10",
      "title": "Ensure unused filesystems kernel modules are not available",
      "section": "1.1.1 Configure Filesystem Kernel Modules",
      "profile": "Level1",
      "automated": false,
      "type": "Manual",
      "expected": "Review and disable unused filesystem kernel modules",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.1.10",
      "description": "Filesystem kernel modules are pieces of code that can be dynamically loaded into the Linux kernel to extend its filesystem capabilities, or so -called base kernel, of an operating system. Filesystem kernel modules are typically used to add support for new hardware (as device drivers), or for adding system calls.",
      "remediation": "- IF - the module is available in the running kernel:\n• Unload the filesystem kernel module from the kernel • Create a file ending in .conf with install filesystem kernel modules /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with deny list filesystem kernel modules in the /etc/modprobe.d/ directory WARNING : unloading, disabling or denylisting filesystem modules that are in use on the system maybe FATAL. It is extremely important to thoroughly review the filesystems returned by the audit before following the remediation procedure.\nExample of unloading the gfs2 kernel module:\n# modprobe -r gfs2 2>/dev/null\n# rmmod gfs2 2>/dev/null Example of fully disabling the gfs2 kernel module:\n# printf '%s ' \"blacklist gfs2\" \"install gfs2 /bin/false\" >> /etc/modprobe.d/gfs2.conf Note:\n• Disabling a kernel module by modifying the command above for each unused filesystem kernel module • The example gfs2 must be updated with the appropriate module name for the command or example script bellow to run correctly.\nBelow is an example Script that can be modified to use on various filesystem kernel modules manual remediation process:\nExample Script\n#!/usr/bin/env bash a_output2=(); a_output3=(); l_dl=\"\" # Initialize arrays and clear variables l_mod_name=\"gfs2\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '(install|blacklist) +'\"$l_mod_name// -/_\"'') if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name \\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '+'\"$l_mod_name// - /_\"'+(\\/usr)?\\/bin\\/(true|false) ' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - setting kernel module: \\\"$l_mod_name \\\" to \\\"$(readlin k -f /bin/false) \\\"\") printf '%s ' \"install $l_mod_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '+'\"$l_mod_name// -/_\"'' <<< \"$a_showconfig[*]\"; then a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name \\\"\") printf '%s ' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/$l_mod_name/ -/\\/\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/$l_mod_name/ -/\\/\")\" ]; then a_output3+=(\" - \\\"$l_mod_base_directory \\\"\") [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"$l_mod_name:: -2\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name \\\" doesn't exist in \\\"$l_mod_base_directory \\\"\" fi done [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" -- INFO --\" \" - module:\n\\\"$l_mod_name \\\" exists in:\" \"$a_output3[@]\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\" || printf '%s ' \"\" \" - No changes needed\" printf '%s ' \"\" \" - remediation of kernel module: \\\"$l_mod_name \\\" complete\" \"\""
    },
    {
      "id": "1.1.2.1.1",
      "title": "Ensure /tmp is a separate partition",
      "section": "1.1.2.1 Configure /tmp",
      "profile": "Level2",
      "automated": true,
      "type": "MountPoint",
      "mount_point": "/tmp",
      "expected_status": "separate_partition",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.2.1.1",
      "description": "The /tmp directory is a world -writable directory used for temporary storage by all users and some applications.\n- IF - an entry for /tmp exists in /etc/fstab it will take precedence over entries in systemd default unit file.\nNote: In an environment where the main system is diskless and connected to iSCSI, entries in /etc/fstab may not take precedence.\n/tmp can be configured to use tmpfs .\ntmpfs puts everything into the kernel internal caches and grows and shrinks to accommodate the files it contains and is able to swap unneeded pages out to swap space. It has maximum size limits which can be adjusted on the fly via mount -o remount .\nSince tmpfs lives completely in the page cache and on swap, all tmpfs pages will be shown as \"Shmem\" in /proc/meminfo and \"Shared\" in free . Notice that these counters also include shared memory. The most reliable way to get the count is using df and du.\ntmpfs has three mount options for sizing:\n• size : The limit of allocated bytes for this tmpfs instance. The default is half of your physical RAM without swap. If you oversize your tmpfs instances the machine will deadlock since the OOM handler will not be able to free that memory.\n• nr_blocks : The same as size, but in blocks of PAGE_SIZE.\n• nr_inodes : The maximum number of inodes for this instance. The default is half of the number of your physical RAM pages, or (on a machine with highmem) the number of lowmem RAM pages, whichever is the lower.\nThese parameters accept a suffix k, m or g and can be changed on remount. The size parameter also accepts a suffix % to limit this tmpfs instance to that percentage of your physical RAM. The default, when neither size nor nr_blocks is specified, is size=50% .\n",
      "remediation": "First ensure that systemd is correctly configured to ensure that /tmp will be mounted at boot time.\n# systemctl unmask tmp.mount For specific configuration requirements of the /tmp mount for your environment, modify /etc/fstab .\nExample of using tmpfs with specific mount options:\ntmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0 Note: the size=2G is an example of setting a specific size for tmpfs .\nExample of using a volume or disk with specific mount options. The source location of the volume or disk will vary depending on your environment:\n<device> /tmp <fstype> defaults,nodev,nosuid,noexec 0 0"
    },
    {
      "id": "1.1.2.1.2",
      "title": "Ensure nodev option set on /tmp partition",
      "section": "1.1.2.1 Configure /tmp",
      "profile": "Level1",
      "automated": true,
      "type": "MountOption",
      "mount_point": "/tmp",
      "required_option": "nodev",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.2.1.2",
      "description": "The nodev mount option specifies that the filesystem cannot contain special devices.",
      "remediation": "- IF - a separate partition exists for /tmp .\nEdit the /etc/fstab file and add nodev to the fourth field (mounting options) for the /tmp partition.\nExample:\n<device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0\nRun the following command to remount /tmp with the configured options:\n# mount -o remount /tmp"
    },
    {
      "id": "1.1.2.1.3",
      "title": "Ensure nosuid option set on /tmp partition",
      "section": "1.1.2.1 Configure /tmp",
      "profile": "Level1",
      "automated": true,
      "type": "MountOption",
      "mount_point": "/tmp",
      "required_option": "nosuid",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.2.1.3",
      "description": "The nosuid mount option specifies that the filesystem cannot contain setuid files.",
      "remediation": "- IF - a separate partition exists for /tmp .\nEdit the /etc/fstab file and add nosuid to the fourth field (mounting options) for the /tmp partition.\nExample:\n<device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0\nRun the following command to remount /tmp with the configured options:\n# mount -o remount /tmp"
    },
    {
      "id": "1.1.2.1.4",
      "title": "Ensure noexec option set on /tmp partition",
      "section": "1.1.2.1 Configure /tmp",
      "profile": "Level1",
      "automated": true,
      "type": "MountOption",
      "mount_point": "/tmp",
      "required_option": "noexec",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "1.1.2.1.4",
      "description": "The noexec mount option specifies that the filesystem cannot contain executable binaries.",
      "remediation": "- IF - a separate partition exists for /tmp .\nEdit the /etc/fstab file and add noexec to the fourth field (mounting options) for the /tmp partition.\nExample:\n<device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0\nRun the following command to remount /tmp with the configured options:\n# mount -o remount /tmp"
    }
  ]
}