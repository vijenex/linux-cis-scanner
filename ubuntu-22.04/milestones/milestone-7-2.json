{
  "milestone": "7.2 Local User and Group Settings",
  "version": "1.0.0",
  "description": "Ubuntu 22.04 LTS CIS Benchmark - Section 7.2 Local User and Group Settings",
  "controls": [
    {
      "id": "7.2.1",
      "title": "Ensure accounts in /etc/passwd use shadowed passwords",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "ShadowedPasswords",
      "passwd_file": "/etc/passwd",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.1",
      "description": "Local accounts can uses shadowed passwords. With shadowed passwords, The passwords are saved in shadow password file, /etc/shadow , encrypted by a salted one-way hash. Accounts with a shadowed password have an x in the second field in /etc/passwd .",
      "remediation": "Run the following command to set accounts to use shadowed passwords and migrate passwords in /etc/passwd to /etc/shadow :\n# pwconv Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off.\nInternal Only - General"
    },
    {
      "id": "7.2.2",
      "title": "Ensure /etc/shadow password fields are not empty",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "EmptyPasswords",
      "shadow_file": "/etc/shadow",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.2",
      "description": "An account with an empty password field means that anybody may log in as that user without providing a password.",
      "remediation": "If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:\n# passwd -l <username> Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off."
    },
    {
      "id": "7.2.3",
      "title": "Ensure all groups in /etc/passwd exist in /etc/group",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "GroupConsistency",
      "passwd_file": "/etc/passwd",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.3",
      "description": "Over time, system administration errors and changes can lead to groups being defined in /etc/passwd but not in /etc/group .",
      "remediation": "Analyze the output of the Audit step above and perform the appropriate action to correct any discrepancies found."
    },
    {
      "id": "7.2.4",
      "title": "Ensure shadow group is empty",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "EmptyGroup",
      "group_name": "shadow",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.4",
      "description": "The shadow group allows system programs which require access the ability to read the /etc/shadow file. No users should be assigned to the shadow group.",
      "remediation": "Run the following command to remove all users from the shadow group\n# sed -ri 's/(^shadow:[^:]*:[^:]*:)([^:]+$)/ \\1/' /etc/group Change the primary group of any users with shadow as their primary group.\n# usermod -g <primary group> <user>"
    },
    {
      "id": "7.2.5",
      "title": "Ensure no duplicate UIDs exist",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "DuplicateUIDs",
      "passwd_file": "/etc/passwd",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.5",
      "description": "Although the useradd program will not let you create a duplicate User ID (UID), it is possible for an administrator to manually edit the /etc/passwd file and change the UID field.",
      "remediation": "Based on the results of the audit script, establish unique UIDs and review all files owned by the shared UIDs to determine which UID they are supposed to belong to."
    },
    {
      "id": "7.2.6",
      "title": "Ensure no duplicate GIDs exist",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "DuplicateGIDs",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.6",
      "description": "Although the groupadd program will not let you create a duplicate Group ID (GID), it is possible for an administrator to manually edit the /etc/group file and change the GID field.",
      "remediation": "Based on the results of the audit script, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to."
    },
    {
      "id": "7.2.7",
      "title": "Ensure no duplicate user names exist",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "DuplicateUsernames",
      "passwd_file": "/etc/passwd",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.7",
      "description": "Although the useradd program will not let you create a duplicate user name, it is possible for an administrator to manually edit the /etc/passwd file and change the user name.",
      "remediation": "Based on the results of the audit script, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs."
    },
    {
      "id": "7.2.8",
      "title": "Ensure no duplicate group names exist",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "DuplicateGroupnames",
      "group_file": "/etc/group",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.8",
      "description": "Although the groupadd program will not let you create a duplicate group name, it is possible for an administrator to manually edit the /etc/group file and change the group name.",
      "remediation": "Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs."
    },
    {
      "id": "7.2.9",
      "title": "Ensure local interactive user home directories are configured",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "UserHomeDirs",
      "passwd_file": "/etc/passwd",
      "min_uid": 1000,
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.9",
      "description": "The user home directory is space defined for the particular user to set local environment variables and to store personal files. While the system administrator can establish secure permissions for users' home directories, the users can easily override thes e.\nUsers can be defined in /etc/passwd without a home directory or with a home directory that does not actually exist.",
      "remediation": "If a local interactive users' home directory is undefined and/or doesn't exist, follow local site policy and perform one of the following:\n• Lock the user account • Remove the user from the system • create a directory for the user. If undefined, edit /etc/passwd and add the absolute path to the directory to the last field of the user.\nRun the following script to:\n• Remove excessive permissions from local interactive users home directories • Update the home directory's owner Internal Only - General #!/usr/bin/env bash a_output=() a_output2=() a_exists2=() a_mode2=() a_owner2=() l_valid_shells=\"^($( awk -F\\/ '$NF != \"nologin\" print' /etc/shells | sed -rn '/^\\//s,/,\\\\\\\\/,g;p' | paste -s -d '|' - ))$\" l_mask='0027'; l_max=\"$( printf '%o' $(( 0777 & ~$l_mask)) )\" l_users=\"$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat print $1 \" \"\n$(NF-1) ' /etc/passwd | wc -l)\" [ \"$l_users\" -gt 10000 ] && printf '%s ' \"\" \" ** INFO **\" \\ \" $l_users Local interactive users found on the system\" \" This may be a long running process\" \" **********\" while IFS=\" \" read -r l_user l_home; do if [ -d \"$l_home\" ]; then while IFS=: read -r l_own l_mode; do if [ \"$l_user\" != \"$l_own\" ]; then a_owner2+=(\" - User: \\\"$l_user \\\" Home \\\"$l_home \\\" is owned by: \\\"$l_own\\\"\" \\ \" changing owner to: \\\"$l_user \\\"\") && chown \"$l_user\" \"$l_home\" fi if [ $(( $l_mode & $l_mask )) -gt 0 ]; then a_mode2+=(\" - User: \\\"$l_user \\\" Home \\\"$l_home \\\" is mode:\n\\\"$l_mode \\\"\" \\ \" changing to mode: \\\"$l_max\\\" or more restrictive\") chmod g-w,o-rwx \"$l_home\" fi done <<< \"$(stat -Lc '%U:%#a' \"$l_home\")\" else a_exists2+=(\" - User: \\\"$l_user \\\" Home Directory: \\\"$l_home \\\" Doesn't exist\") fi done <<< \"$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat print $1 \" \"\n$(NF-1) ' /etc/passwd)\" [ \"$#a_exists2[@]\" -gt 0 ] && a_output2+=(\"$a_exists2[@]\") [ \"$#a_mode2[@]\" -gt 0 ] && a_output2+=(\"$a_mode2[@]\") [ \"$#a_owner2[@]\" -gt 0 ] && a_output2+=(\"$a_owner2[@]\") if [ \"$#a_output2[@]\" -gt 0 ]; then printf '%s ' \"\" \"$a_output2[@]\" else printf '%s ' \"\" \"- No changes required\" fi"
    },
    {
      "id": "7.2.10",
      "title": "Ensure local interactive user dot files access is configured",
      "section": "System Maintenance",
      "profile": "Level1",
      "type": "UserDotFiles",
      "passwd_file": "/etc/passwd",
      "min_uid": 1000,
      "max_permissions": "go-w",
      "cis_reference": "https://www.cisecurity.org/benchmark/ubuntu_linux",
      "cis_control_id": "7.2.10",
      "description": "While the system administrator can establish secure permissions for users' \"dot\" files, the users can easily override these.\n• .forward file specifies an email address to forward the user's mail to.\n• .rhost file provides the \"remote authentication\" database for the rcp, rlogin, and rsh commands and the rcmd() function. These files bypass the standard password -based user authentication mechanism. They specify remote hosts and users that are considered trusted (i.e. are allowed to access the local system without supplying a password) • .netrc file contains data for logging into a remote host or passing authentication to an API.\n• .bash_history file keeps track of the user’s commands.",
      "remediation": "Making global modifications to users' files without alerting the user community can result in unexpected outages and unhappy users. Therefore, it is recommended that a monitoring policy be established to report user dot file permissions and determine the action to be taken in accordance with site policy.\nThe following script will:\n• remove excessive permissions on dot files within interactive users' home directories • change ownership of dot files within interactive users' home directories to the user • change group ownership of dot files within interactive users' home directories to the user's primary group • list .forward and .rhost files to be investigated and manually deleted Internal Only - General #!/usr/bin/env bash a_output2=(); a_output3=() l_maxsize=\"1000\" # Maximum number of local interactive users before warning (Default 1,000) l_valid_shells=\"^($( awk -F\\/ '$NF != \"nologin\" print' /etc/shells | sed -rn '/^\\//s,/,\\\\\\\\/,g;p' | paste -s -d '|' - ))$\" a_user_and_home=() # Create array with local users and their home directories while read -r l_local_user l_local_user_home; do # Populate array with users and user home location [[ -n \"$l_local_user\" && -n \"$l_local_user_home\" ]] && a_user_and_home+=(\"$l_local_user:$l_local_user_home\") done <<< \"$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat print $1 \" \" $(NF -1) ' /etc/passwd)\" l_asize=\"$#a_user_and_home[@]\" # Here if we want to look at number of users before proceeding [ \"$#a_user_and_home[@]\" -gt \"$l_maxsize\" ] && printf '%s ' \"\" \" ** INFO **\" \\ \" - \\\"$l_asize \\\" Local interactive users found on the system\" \\ \" - This may be a long running check\" \"\" file_access_fix() a_access_out=() l_max=\"$( printf '%o' $(( 0777 & ~$l_mask)) )\" if [ $(( $l_mode & $l_mask )) -gt 0 ]; then printf '%s ' \"\" \" - File: \\\"$l_hdfile \\\" is mode: \\\"$l_mode \\\" and should be mode: \\\"$l_max\\\" or more restrictive\" \\ \" Updating file: \\\"$l_hdfile \\\" to be mode: \\\"$l_max\\\" or more restrictive\" chmod \"$l_change\" \"$l_hdfile\" fi if [[ ! \"$l_owner\" =~ ($l_user) ]]; then printf '%s ' \"\" \" - File: \\\"$l_hdfile \\\" owned by: \\\"$l_owner \\\" and should be owned by \\\"$l_user//|/ or \\\"\" \\ \" Updating file: \\\"$l_hdfile \\\" to be owned by \\\"$l_user//|/ or \\\"\" chown \"$l_user\" \"$l_hdfile\" fi if [[ ! \"$l_gowner\" =~ ($l_group) ]]; then printf '%s ' \"\" \" - File: \\\"$l_hdfile \\\" group owned by: \\\"$l_gowner \\\" and should be group owned by \\\"$l_group//|/ or \\\"\" \\ \" Updating file: \\\"$l_hdfile \\\" to be group owned by \\\"$l_group//|/ or \\\"\" chgrp \"$l_group\" \"$l_hdfile\" fi while IFS=: read -r l_user l_home; do a_dot_file=(); a_netrc=(); a_netrc_warn=(); a_bhout=(); a_hdirout=() if [ -d \"$l_home\" ]; then l_group=\"$(id -gn \"$l_user\" | xargs)\";l_group=\"$l_group// /|\" while IFS= read -r -d $'\\0' l_hdfile; do while read -r l_mode l_owner l_gowner; do case \"$(basename \"$l_hdfile\")\" in .forward | .rhost ) a_dot_file+=(\" - File: \\\"$l_hdfile \\\" exists\" \" Please review and manually delete this file\") ;;\n.netrc ) l_mask='0177'; l_change=\"u -x,go-rwx\"; file_access_fix a_netrc_warn+=(\" - File: \\\"$l_hdfile \\\" exists\") ;;\n.bash_history ) l_mask='0177'; l_change=\"u -x,go-rwx\"; file_access_fix ;;\n* ) l_mask='0133'; l_change=\"u -x,go-wx\"; file_access_fix ;;\nesac done < <(stat -Lc '%#a %U %G' \"$l_hdfile\") done < <(find \"$l_home\" -xdev -type f -name '.*' -print0) fi [ \"$#a_dot_file[@]\" -gt 0 ] && a_output2+=(\" - User: \\\"$l_user \\\" Home Directory: \\\"$l_home \\\"\" \"$a_dot_file[@]\") [ \"$#a_netrc_warn[@]\" -gt 0 ] && a_output3+=(\" - User: \\\"$l_user \\\" Home Directory: \\\"$l_home \\\"\" \"$a_netrc_warn[@]\") done <<< \"$(printf '%s ' \"$a_user_and_home[@]\")\" [ \"$#a_output3[@]\" -gt 0 ] && printf '%s ' \"\" \" ** WARNING **\" \"$a_output3[@]\" \"\" [ \"$#a_output2[@]\" -gt 0 ] && printf '%s ' \"\" \"$a_output2[@]\""
    }
  ]
}